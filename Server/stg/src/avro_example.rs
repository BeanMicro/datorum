use apache_avro::{self as avro, Schema, AvroSchema, Writer, Reader};
use serde::{Deserialize, Serialize};

// Demonstration data structure to be serialized/deserialized with Avro.
// The derive feature of apache-avro provides the AvroSchema derive macro.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, avro::AvroSchema)]
pub struct DemoEvent {
    pub id: i64,
    pub name: String,
    pub active: bool,
}

/// Perform an Avro round-trip for a demo value to verify integration works.
pub fn demo_avro_roundtrip() -> Result<(), Box<dyn std::error::Error>> {
    let original = DemoEvent { id: 42, name: "example".into(), active: true };

    // Obtain the schema generated by the derive macro.
    let schema: Schema = DemoEvent::get_schema();

    // Convert the struct into a generic Avro Value via Serde -> apache-avro.
    let value = avro::to_value(original.clone())?;

    // Serialize datum using a Writer.
    let mut writer = Writer::new(&schema, Vec::new());
    writer.append(value.clone())?;
    let buf = writer.into_inner()?; // Encoded Avro binary

    // Deserialize back via a Reader.
    let mut reader = Reader::with_schema(&schema, &buf[..])?;
    let decoded_value = reader
        .next()
        .ok_or_else(|| "No value read back from Avro buffer")??; // AvroResult<Value>

    // Convert Avro Value back into strongly typed struct.
    let decoded: DemoEvent = avro::from_value(&decoded_value)?;

    assert_eq!(decoded, original, "Avro round-trip value mismatch");

    println!("Avro round-trip successful: {:?}", decoded);
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn avro_round_trip() {
        demo_avro_roundtrip().expect("Avro round trip failed");
    }
}
